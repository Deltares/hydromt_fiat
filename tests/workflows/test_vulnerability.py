import pandas as pd
import pytest

from hydromt_fiat.utils import (
    CURVE,
    CURVE_ID,
    DAMAGE,
    EXPOSURE_LINK,
    EXPOSURE_TYPE,
    SUBTYPE,
)
from hydromt_fiat.workflows import process_vulnerability_linking, vulnerability_setup
from tests.conftest import HAS_INTERNET, HAS_LOCAL_DATA

pytestmark = pytest.mark.skipif(
    not HAS_INTERNET and not HAS_LOCAL_DATA,
    reason="No internet or local data available",
)


def test_process_vulnerability_linking(
    vulnerability_data_row_oriented: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # Execute the function
    link = process_vulnerability_linking(
        types=vulnerability_data_row_oriented[CURVE].values,
        vulnerability_linking=vulnerability_linking,
    )

    # Assert the output
    assert len(link) == 8
    assert SUBTYPE in link.columns
    assert CURVE_ID in link.columns
    assert not all(link[EXPOSURE_LINK] == link[CURVE])
    assert "roads" not in link[CURVE].values


def test_process_vulnerability_linking_no_subtype(
    vulnerability_data_row_oriented: pd.DataFrame,
    vulnerability_linking_alt: pd.DataFrame,
):
    # Execute the function
    link = process_vulnerability_linking(
        types=vulnerability_data_row_oriented[CURVE].values,
        vulnerability_linking=vulnerability_linking_alt,
    )

    # Assert the output
    assert len(link) == 5
    assert SUBTYPE not in link.columns


def test_process_vulnerability_linking_no_link(
    vulnerability_data_row_oriented: pd.DataFrame,
):
    # Execute the function
    link = process_vulnerability_linking(
        types=vulnerability_data_row_oriented[CURVE].values,
        vulnerability_linking=None,  # Explicit so its easy to follow
    )

    # Assert the output
    assert len(link) == 6
    assert all(link[EXPOSURE_LINK] == link[CURVE])
    assert "roads" in link[CURVE].values
    assert all(link[EXPOSURE_TYPE] == DAMAGE)


def test_process_vulnerability_linking_error(
    vulnerability_data_row_oriented: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # No 'curve' column in the provided linking table
    with pytest.raises(
        KeyError,
        match="The 'curve' column in not present in the linking table",
    ):
        _ = process_vulnerability_linking(
            types=vulnerability_data_row_oriented[CURVE].values,
            vulnerability_linking=vulnerability_linking.drop(CURVE, axis=1),
        )


def test_vulnerability_setup(
    vulnerability_data: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # Execute the workflow function
    vuln_curves, vuln_id = vulnerability_setup(
        vulnerability_data=vulnerability_data,
        vulnerability_linking=vulnerability_linking,
        continent="europe",
    )

    assert len(vuln_curves.columns) == 6
    assert len(vuln_id.columns) == 5
    assert "rs1" in vuln_curves.columns
    assert "in1" in vuln_curves.columns
    assert "rs1" in vuln_id[CURVE_ID].values
    assert "in1" in vuln_id[CURVE_ID].values


def test_vulnerability_setup_typing(
    vulnerability_data: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # Check for selecting specific types
    vuln_curves, vuln_id = vulnerability_setup(
        vulnerability_data=vulnerability_data,
        vulnerability_linking=vulnerability_linking,
        continent="europe",
        curve=["rs1", "cm1"],
    )

    assert len(vuln_curves.columns) == 3
    assert "rs1" in vuln_curves.columns
    assert "rs1" in vuln_id[CURVE_ID].values
    assert "in1" not in vuln_curves.columns
    assert "in1" not in vuln_id[CURVE_ID].values


def test_vulnerability_setup_no_linking(vulnerability_data: pd.DataFrame):
    # No linking at all
    vuln_curves, vuln_id = vulnerability_setup(
        vulnerability_data=vulnerability_data,
        continent="europe",
        curve=["rs1", "cm1"],
    )
    assert len(vuln_curves.columns) == 3
    assert (vuln_id[EXPOSURE_LINK].values == vuln_id[CURVE_ID].values).all()


def test_vulnerability_setup_row_oriented(
    vulnerability_data_row_oriented: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # Execute the workflow function
    vuln_curves, vuln_id = vulnerability_setup(
        vulnerability_data=vulnerability_data_row_oriented,
        vulnerability_linking=vulnerability_linking,
        continent="europe",
        column_oriented=False,
    )

    assert len(vuln_curves.columns) == 6
    assert len(vuln_id.columns) == 5
    assert "rs1" in vuln_curves.columns
    assert "in1" in vuln_curves.columns
    assert "rs1" in vuln_id[CURVE_ID].values
    assert "in1" in vuln_id[CURVE_ID].values


def test_vulnerability_setup_units(
    caplog: pytest.LogCaptureFixture,
    vulnerability_data: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # First with meters
    vuln_curves, _ = vulnerability_setup(
        vulnerability_data=vulnerability_data,
        vulnerability_linking=vulnerability_linking,
        continent="europe",
        curve=["residential", "commercial"],
    )
    mean_val = int(vuln_curves["water depth"].mean() * 100)
    assert mean_val == 500

    # Assert that different units work (in this case feet)
    vuln_curves, _ = vulnerability_setup(
        vulnerability_data=vulnerability_data,
        vulnerability_linking=vulnerability_linking,
        unit="ft",
        continent="europe",
        curve=["residential", "commercial"],
    )
    mean_val_ft = int(vuln_curves["water depth"].mean() * 100)
    assert mean_val > 3 * mean_val_ft
    assert (
        "Given unit (ft) does not match the standard unit (m) for length" in caplog.text
    )


def test_vulnerability_setup_error(
    vulnerability_data: pd.DataFrame,
    vulnerability_linking: pd.DataFrame,
):
    # No 'type' column in datasets, drop the first row in which it is located
    vuln_no_type = vulnerability_data.drop(1)
    with pytest.raises(
        KeyError,
        match="The 'curve' column in not present in the vulnerability data",
    ):
        _ = vulnerability_setup(
            vulnerability_data=vuln_no_type,
            continent="europe",
            curve=["residential", "commercial"],
        )
