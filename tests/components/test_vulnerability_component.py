import logging
from pathlib import Path
from unittest.mock import MagicMock, PropertyMock

import pandas as pd
import pytest
from hydromt.model import ModelRoot

from hydromt_fiat import FIATModel
from hydromt_fiat.components import VulnerabilityComponent
from hydromt_fiat.components.vulnerability import VulnerabilityData


def test_vulnerability_data_errors():
    # Construct an empty data container
    x = VulnerabilityData(pd.DataFrame(), pd.DataFrame())

    # Error on wrong get
    with pytest.raises(
        KeyError,
        match="Can't get 'foo'",
    ):
        _ = x["foo"]

    # Error on wrong set
    with pytest.raises(
        KeyError,
        match="Can't set 'foo' in VulnerabilityData class",
    ):
        x["foo"] = 2


def test_vulnerability_component_empty(
    mock_model: MagicMock,
):
    # Setup the component
    component = VulnerabilityComponent(model=mock_model)

    # Assert the content
    assert component._filename == "vulnerability/curves.csv"
    assert component.data.curves.empty
    assert isinstance(component.data, VulnerabilityData)


def test_vulnerability_component_set(
    caplog: pytest.LogCaptureFixture,
    mock_model: MagicMock,
    vulnerability_curves: pd.DataFrame,
):
    caplog.set_level(logging.WARNING)
    # Setup the component
    component = VulnerabilityComponent(model=mock_model)
    # Assert current state
    assert component.data.curves.empty

    # Call the method
    component.set(vulnerability_curves, name="curves")
    # Assert the state
    assert not component.data.curves.empty

    # Overwrite and trigger warning
    component.set(vulnerability_curves, name="curves")
    # Assert the warning
    assert "Replacing vulnerabilty data: curves" in caplog.text


def test_vulnerability_component_read(
    mock_model_config: MagicMock,
    model_cached: Path,
):
    type(mock_model_config).root = PropertyMock(
        side_effect=lambda: ModelRoot(model_cached, mode="r"),
    )
    # Setup the component
    component = VulnerabilityComponent(model=mock_model_config)

    # Read by calling the data property, thereby falling back on the config entry
    # As there is a config entry present
    component.data

    # Assert the state
    assert not component.data.curves.empty
    assert not component.data.identifiers.empty


def test_vulnerability_component_read_sig(
    mock_model_config: MagicMock,
    model_cached: Path,
):
    type(mock_model_config).root = PropertyMock(
        side_effect=lambda: ModelRoot(model_cached, mode="r"),
    )
    # Setup the component
    component = VulnerabilityComponent(model=mock_model_config)

    # Read with argument
    component.read("vulnerability/curves.csv")

    # Assert the state
    assert not component.data.curves.empty
    assert not component.data.identifiers.empty


def test_vulnerability_component_write(
    tmp_path: Path,
    mock_model_config: MagicMock,
    vulnerability_curves: pd.DataFrame,
):
    # Setup the component
    component = VulnerabilityComponent(model=mock_model_config)

    # Set data like a dummy
    component.data["curves"] = vulnerability_curves

    # Write the data
    component.write()

    # Assert the output
    assert Path(tmp_path, "vulnerability", "curves.csv").is_file()
    # Assert the config
    assert component.model.config.get("vulnerability.file") == Path(
        tmp_path,
        "vulnerability",
        "curves.csv",
    )


def test_vulnerability_component_write_empty(
    caplog: pytest.LogCaptureFixture,
    mock_model: MagicMock,
):
    caplog.set_level(logging.INFO)
    # Setup the component
    component = VulnerabilityComponent(model=mock_model)

    # Write the data
    component.write()

    # Assert the logging
    assert "No vulnerability curves encountered, skipping.." in caplog.text


def test_vulnerability_component_write_sig(
    tmp_path: Path,
    mock_model_config: MagicMock,
    vulnerability_curves: pd.DataFrame,
):
    # Setup the component
    component = VulnerabilityComponent(model=mock_model_config)

    # Set data like a dummy
    component.data["curves"] = vulnerability_curves

    # Write the data
    component.write("foo.csv", index=False)

    # Assert the output
    assert Path(tmp_path, "foo.csv").is_file()
    # Assert the config
    assert component.model.config.get("vulnerability.file") == Path(
        tmp_path,
        "foo.csv",
    )


def test_vulnerability_component_setup(model: FIATModel):
    # Setup the component
    component = VulnerabilityComponent(model=model)

    # Assert it's empty
    assert component.data.curves.empty

    # Setup the vulnerability
    component.setup(
        vulnerability_fname="vulnerability_curves",
        vulnerability_linking_fname="vulnerability_curves_linking",
        continent="europe",
    )

    assert not component.data.curves.empty
    assert not component.data.identifiers.empty
