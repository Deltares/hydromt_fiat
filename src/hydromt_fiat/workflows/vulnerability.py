"""Vulnerability workflows."""

import pandas as pd
from barril.units import Scalar

__all__ = ["vulnerability_curves"]


def vulnerability_curves(
    vuln_data: pd.DataFrame,
    vuln_linking: pd.DataFrame | None = None,
    unit: str = "m",
    index_name: str = "water depth",
    **select: dict,
):
    """_summary_.

    Parameters
    ----------
    vuln_data : pd.DataFrame
        _description_
    vuln_linking : pd.DataFrame
        _description_
    unit : str
        _description_
    """
    # Quick check on the data
    if "type" not in vuln_data:
        raise KeyError("'type' column in not present in the vulnerability data")
    # Build a query from the index kwargs
    if len(select) != 0:
        query = ""
        idx = 0
        for key, item in select.items():
            if idx != 0:
                query += " and "
            idx += 1
            if isinstance(item, (list, tuple)):
                query += f"{key} in {str(item)}"
                continue
            if isinstance(item, str):
                item = f"'{item}'"
            query += f"{key} == {str(item)}"
        vuln_data = vuln_data.query(query)

    # Query the linking data
    if vuln_linking is None:
        vuln_linking = pd.DataFrame(
            data={
                "link": vuln_data["type"].values,
                "type": vuln_data["type"].values,
            }
        )
    vuln_linking.loc[:, "curve_id"] = vuln_linking["type"]
    types = vuln_data.type.values.tolist()
    vuln_linking = vuln_linking.query(f"type in {str(types)}")

    # Sort the sub typing of the objects
    if "subtype" in vuln_linking.columns:
        vuln_linking.loc[:, "curve_id"] = (
            vuln_linking["type"] + "_" + vuln_linking["subtype"]
        )
    vuln_linking = vuln_linking.drop_duplicates(subset="curve_id")
    on = "type"
    if "subtype" in vuln_data.columns:
        vuln_data.loc[:, "curve_id"] = vuln_data["type"] + "_" + vuln_data["subtype"]
        on = "curve_id"
    vuln_data = pd.merge(vuln_data, vuln_linking, on=on, how="inner")

    # Reshape the vulnerability data
    columns = list(set(list(select.keys()) + vuln_linking.columns.to_list()))
    columns.remove("curve_id")
    vuln_data.drop(columns, axis=1, inplace=True)
    vuln_data = vuln_data.transpose()
    vuln_data.rename(columns=vuln_data.loc["curve_id"], inplace=True)
    vuln_data.drop("curve_id", inplace=True)
    vuln_data.index.name = index_name

    # Again query the linking table based on the vulnerability curves
    # But this time on the curve ID
    types = vuln_data.columns.tolist()
    vuln_linking = vuln_linking.query(f"curve_id in {str(types)}")

    # At last reset the index
    vuln_data.reset_index(inplace=True)
    vuln_data = vuln_data.astype(float)

    # Scale the data according to the unit
    default_unit = Scalar(1, "m")
    arg_unit = Scalar(1, unit)
    conversion = arg_unit / default_unit
    vuln_data[index_name] *= conversion.value

    return vuln_data, vuln_linking
