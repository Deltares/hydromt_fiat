import pandas as pd
from pandas.api.types import is_numeric_dtype
import numpy as np
import logging
from hydromt_fiat.workflows.utils import detect_delimiter
from typing import List
from pathlib import Path
from typing import Union, Tuple
import math


class Vulnerability:
    def __init__(
        self,
        unit: str = "meters",
        logger: logging.Logger = None,
        fn: Union[str, Path] = None,
    ):
        """A class for creating, adding, and updating damage functions to use in
        Delft-FIAT.

        Attributes
        ----------
        hazard_name : str
            The name of the hazard variable in the damage functions.
        hazard_values : list
            The hazard values of the damage functions. This variable is updated when a
            new damage function is added which has different hazard values than the
            current.
        functions : dict
            A dictionary of the damage functions fractions.
        unit : str
            The unit of the hazard values in the damage functions (e.g. of the water
            depth), by default "meters"
        extraction_method : dict
            A dictionary of the extract_method for each damage function.
        logger : logging.Logger
            A logger object for logging messages.

        Methods
        -------
        __init__(self, unit='meter', logger=None, fn=None)
            Initializes a new Vulnerability object.
        read(self, fn)
            Reads the vulnerability data from a CSV file.
        from_csv(self, fn)
            Reads in one or multiple CSVs containing damage functions and adds them to
            the vulnerability functions variable.
        from_table(self, vulnerability_functions)
            Reads an existing Delft-FIAT damage function (i.e. vulnerability_curves.csv)
            file.
        add(self, name, hazard_values, fraction_values)
            Adds a vulnerability function.
        add_multiple(self, names, hazard_values, fraction_values_list)
            Adds multiple vulnerability functions.
        update(self, name, hazard_values, fraction_values)
            Updates an existing vulnerability function.
        set_area_extraction_methods(self, method='mean')
            Sets the area extract_method for all damage functions.
        get_new_hazard_values(self, hazard_values)
            Returns the new hazard values of the existing and to be added damage
            functions.
        """
        self.hazard_name = f"water depth [{unit}]"
        self.hazard_values = list()
        self.functions = dict()
        self.unit = unit
        self.extraction_method = dict()
        self.logger = logger

        if fn is not None:
            self.vulnerability = self.read(fn)

    def read(self, fn: Union[str, Path]):
        """Read the vulnerability data.

        Parameters
        ----------
        fn : Union[str, Path]
            The path to the Delft-FIAT damage function database (CSV) file.
        """
        csv_delimiter = detect_delimiter(fn)
        vulnerability_functions = pd.read_csv(
            fn, delimiter=csv_delimiter, engine="c", skiprows=2
        )

        self.from_table(vulnerability_functions)

        # Read the extract_methods
        extraction_methods = (
            pd.read_csv(fn, delimiter=csv_delimiter, engine="c")
            .reset_index()
            .iloc[0]
            .values[1:]
        )

        # Read the function names
        function_names = (
            pd.read_csv(fn, delimiter=csv_delimiter, engine="c")
            .reset_index()
            .iloc[1]
            .values[1:]
        )

        # Set the extract_methods
        self.extraction_method = dict(zip(function_names, extraction_methods))

        # Read and set the unit
        _unit = (
            (pd.read_csv(fn, delimiter=csv_delimiter, engine="c").columns[0])
            .replace(" ", "")
            .split("=")[-1]
        )
        self.unit = _unit

    def from_csv(self, fn: Union[str, Path]):
        """Reads in one or multiple CSVs containing damage functions and adds them to
        the vulnerability functions variable.

        It is assumed that the first column contains the hazard values and the second
        column contains the damage fractions.

        Parameters
        ----------
        fn : Union[str, Path]
            The path to the CSV file(s) containing the damage functions.
        """
        csvs = [f for f in Path(fn).glob("*.csv")]

        for csv in csvs:
            df = pd.read_csv(csv)
            hazard_values = list(df[df.columns[0]])
            damage_fractions = list(df[df.columns[1]])

            try:
                self.add(csv.stem, hazard_values, damage_fractions)
            except ValueError:
                self.logger.warning(
                    f"Damage function {csv.stem} not added to the "
                    "vulnerability curves."
                )

        # Set the area extract_method to mean (default)
        self.set_area_extraction_methods()

    def from_table(self, vulnerability_functions: pd.DataFrame):
        """Reads an existing Delft-FIAT damage function (i.e. vulnerability_curves.csv)
        file."""
        damage_functions = vulnerability_functions.astype(float)

        self.hazard_name = damage_functions.columns[0]
        self.hazard_values = list(damage_functions[self.hazard_name])

        for c in damage_functions.columns[1:]:
            self.add(c, self.hazard_values, list(damage_functions[c]))

    def add(self, name: str, hazard_values: List[float], fraction_values: List[float]):
        """Adds a vulnerability function.

        Parameters
        ----------
        name : str
            The name of the new vulnerability function.
        hazard_values : List[float]
            The hazard values of the new vulnerability function.
        fraction_values : List[float]
            The fraction values of the new vulnerability function corresponding to the
            hazard values.
        """
        if set(hazard_values) != set(self.hazard_values):
            self.update(name, hazard_values, fraction_values)
        else:
            self.functions[name] = fraction_values

    def add_multiple(
        self,
        names: List[str],
        hazard_values: List[float],
        fraction_values_list: List[List[float]],
    ):
        """Adds multiple vulnerability functions.

        Parameters
        ----------
        names : List[str]
            The names of the new vulnerability functions.
        hazard_values : List[float]
            The hazard values of the new vulnerability functions.
        fraction_values_list : List[List[float]]
            The fraction values of the new vulnerability functions corresponding to the
            hazard values.
        """
        for name, fraction_values in zip(names, fraction_values_list):
            self.add(name, hazard_values, fraction_values)

    def update(
        self, name: str, hazard_values: List[float], fraction_values: List[float]
    ):
        # Get the new hazard values of the existing and to be added damage functions
        _new_hazard_values = self.get_new_hazard_values(hazard_values)
        self.update_single_df(name, hazard_values, fraction_values, _new_hazard_values)

        other_damage_functions = self.get_damage_function_names()
        other_damage_functions.remove(name)

        for df_name in other_damage_functions:
            self.update_single_df(
                df_name, self.hazard_values, self.functions[df_name], _new_hazard_values
            )

        # Update the hazard_values variable
        self.hazard_values = _new_hazard_values

    def set_unit(self, unit: str):
        self.unit = unit

    def update_single_df(
        self,
        name: str,
        new_hazard_values: List[float],
        new_fraction_values: List[float],
        combined_hazard_values: List[float],
    ):
        len_new_fraction_values = len(new_fraction_values)
        len_combined_hazard_values = len(combined_hazard_values)

        if len_new_fraction_values == len_combined_hazard_values:
            _new_fraction_values = new_fraction_values
        elif len_new_fraction_values < len_combined_hazard_values:
            # Tnterpolate the existing damage functions to the new damage function hazard values
            _new_fraction_values = self.interpolate_damage_function(
                new_hazard_values, new_fraction_values, combined_hazard_values
            )
        elif len_new_fraction_values > len_combined_hazard_values:
            difference = len_new_fraction_values - len_combined_hazard_values
            if (max(new_fraction_values) == new_fraction_values[-2]) and (
                difference == 1
            ):
                _new_fraction_values = new_fraction_values[:-1]
            else:
                NotImplemented

        # Add the vulnerability function to the functions variable
        self.functions[name] = _new_fraction_values

    def set_area_extraction_methods(
        self,
        functions_mean: Union[str, List[str], None] = "default",
        functions_max: Union[str, List[str], None] = None,
    ):
        """Sets the area extract_method for all damage functions.

        Parameters
        ----------
        functions_mean : Union[str, List[str], None], optional
            The name(s) of the vulnerability functions that should use the mean hazard
            value when using the area extract_method, by default "default" (this
            means that all vulnerability functions are using mean).
        functions_max : Union[str, List[str], None], optional
            The name(s) of the vulnerability functions that should use the maximum
            hazard value when using the area extract_method, by default None (this
            means that all vulnerability functions are using mean).
        """
        self.set_area_extraction_method(functions_mean, "mean")
        self.set_area_extraction_method(functions_max, "max")

    def set_area_extraction_method(
        self, function_selection: Union[str, List[str]], method: str
    ):
        """Sets the area extract_method for the selected damage functions.

        Parameters
        ----------
        function_selection : Union[str, List[str]]
            The name(s) of the vulnerability functions that should use the selected
            area extract_method.
        method : str
            The area extract_method that should be used for the selected damage
            functions.
        """
        if function_selection == "default":
            self.extraction_method.update({k: method for k in self.functions.keys()})
        if (
            isinstance(function_selection, str)
            and function_selection != "default"
            and function_selection in self.functions.keys()
        ):
            self.extraction_method.update({function_selection: method})
        elif isinstance(function_selection, list):
            self.extraction_method.update(
                {k: method for k in function_selection if k in self.functions.keys()}
            )

    def create_step_function(
        self,
        name: str,
        threshold_value: float = 0.6,
        min_hazard_value: float = 0,
        max_hazard_value: float = 10,
        step_hazard_value: float = 1.0,
    ):
        # list before threshold
        if threshold_value <= 1:
            list_bt = np.arange(min_hazard_value, threshold_value, 0.01).tolist()
            del list_bt[1:-1]
            list_bt.append(threshold_value)
        else:
            list_bt = np.arange(0, threshold_value, step_hazard_value).tolist()
            list_bt.append(threshold_value - 0.01)
            list_bt.append(threshold_value)
        list_bt = [round(elem, 2) for elem in list_bt]

        # list after threshold
        if threshold_value == math.ceil(threshold_value):
            list_at = np.arange(
                math.ceil(threshold_value) + 1, max_hazard_value + 1, step_hazard_value
            ).tolist()
        else:
            list_at = np.arange(
                math.ceil(threshold_value), max_hazard_value + 1, step_hazard_value
            ).tolist()
        # merge list before and after threshold
        hazard_values = list_bt + list_at
        # create fraction_values
        fraction_values = [
            0 if value < threshold_value else 1 for value in hazard_values
        ]

        self.add(name, hazard_values, fraction_values)

        # Set the area extract_method
        self.set_area_extraction_methods()

    def get_damage_function_names(self):
        return list(self.functions.keys())

    def get_vulnerability_functions_from_one_file(
        self,
        df_source: pd.DataFrame,
        df_identifiers_linking: pd.DataFrame,
        continent: Union[str, None] = None,
    ):
        # Identify the unique combinations of values from the identifiers and linking
        # data frame that will be used to select subsets of values from the source data
        # frame.
        # unique_combinations = df_identifiers_linking.groupby(['ID', 'Occupancy', 'Source', 'Description']).unique().reset_index()

        identifier_columns = self.get_identifier_names(df_identifiers_linking)
        df_source = self.add_full_identifier_column(df_source, identifier_columns)
        df_identifiers_linking = self.add_full_identifier_column(
            df_identifiers_linking, identifier_columns
        )

        combined_df = self.link_vfs_from_source(df_source, df_identifiers_linking)

        # Delete the column used to link the dataframes
        del combined_df["full_identifier"]

        # Get the hazard and vulnerability values from the combined data frame
        hazard_values, vulnerability_values = self.get_hazard_and_vulnerability_values(
            combined_df
        )

        # Check whether the vulnerability factors are fractions or percentages and
        # convert into fractions if they are percentages
        if vulnerability_values.max() > 1:
            vulnerability_values = vulnerability_values / 100

        vf_names = [
            name + "_" + type
            for name, type in zip(
                df_identifiers_linking["FIAT Damage Function Name"].values,
                df_identifiers_linking["Damage Type"].values,
            )
        ]

        self.add_multiple(vf_names, hazard_values, vulnerability_values)

    @staticmethod
    def get_identifier_names(
        df: pd.DataFrame,
        to_remove: list = ["FIAT Damage Function Name", "Exposure Link", "Damage Type"],
    ) -> list:
        """_summary_

        Parameters
        ----------
        df : pd.DataFrame
            _description_
        to_remove : list
            _description_

        Returns
        -------
        list
            _description_
        """
        # Check which columns are used as identifiers. These are all columns beside the 'to_remove' columns
        _identifier_columns = list(df.columns)
        for col in to_remove:
            _identifier_columns.remove(col)
        return _identifier_columns

    @staticmethod
    def add_full_identifier_column(
        df: pd.DataFrame, identifier_columns: list
    ) -> pd.DataFrame:
        # Create temporary columns of the identifier columns to be able to filter them
        # with flexible user input
        for c in identifier_columns:
            if is_numeric_dtype(df[c]):
                df[c] = df[c].astype(int).astype(str)

        df["full_identifier"] = df[identifier_columns].apply(
            lambda x: x.str.cat(sep=""), axis=1
        )
        df["full_identifier"] = df["full_identifier"].str.replace(" ", "")
        return df

    def link_vfs_from_source(
        self, vf_source: pd.DataFrame, vf_identifiers_linking: pd.DataFrame
    ) -> pd.DataFrame:
        # Initialize an empty list to hold the subsets
        subsets = []

        # Loop over the unique combinations of values
        for i in range(len(vf_identifiers_linking)):
            # Use the unique combination of values to select the corresponding subset of values
            # from the first data frame using boolean indexing
            subset = vf_source.loc[
                vf_source["full_identifier"]
                == vf_identifiers_linking.loc[i, "full_identifier"]
            ]

            # Check if the subset is empty
            if subset.empty:
                self.logger.warning(
                    f"No vulnerability curves found for unique combination {vf_identifiers_linking.loc[i]}"
                )

            # Append the subset of values to the list of subsets
            subsets.append(subset)

        # Concatenate all of the necessary vulnerability curves info into a single data frame using pd.concat()
        return pd.concat(subsets, ignore_index=True)

    def get_hazard_and_vulnerability_values(
        self, df: pd.DataFrame
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Get the hazard and vulnerability values from the dataframe.

        Parameters
        ----------
        df : pd.DataFrame
            A dataframe containing the hazard and vulnerability values.
            The values can be in rows or in columns.

        Returns
        -------
        Tuple[np.ndarray, np.ndarray]
            A tuple containing the hazard values and the vulnerability values.
        """

        def has_numbers(inputString):
            return any(char.isdigit() for char in inputString)

        hazard_values_in_columns = [c for c in df.columns if has_numbers(c)]

        if len(hazard_values_in_columns) > 0:
            hazard_values = self.get_hazard_values_from_columns(
                hazard_values_in_columns
            )
        else:
            raise ValueError("No hazard values identified in the dataframe.")

        vulnerability_values = df[hazard_values_in_columns].values
        return hazard_values, vulnerability_values

    @staticmethod
    def get_hazard_values_from_columns(columns: list) -> list:
        # Get the hazard values from the column names
        decimal_separators = [".", ","]
        list_hazard_values = list(
            map(
                lambda sub: float(
                    "".join(
                        [
                            ele
                            for ele in sub
                            if ele.isnumeric() or ele in decimal_separators
                        ]
                    )
                ),
                columns,
            )
        )
        if list_hazard_values[0] != 0:
            # The hazard values start with negative values
            list_hazard_values[: list_hazard_values.index(0)] = [
                -x for x in list_hazard_values[: list_hazard_values.index(0)]
            ]
        return list_hazard_values

    @staticmethod
    def add_row_interp(df, x_name, y_name, x_value):
        """method to add a value in a dataframe and interpolate the other values"""
        closest_wd_idx = np.argwhere(np.array(df[x_name]) > x_value)[0][0]

        line = pd.DataFrame(
            {x_name: x_value, y_name: None},
            index=[closest_wd_idx],
        )
        df2 = pd.concat(
            [
                df.iloc[:closest_wd_idx],
                line,
                df.iloc[closest_wd_idx:],
            ]
        ).reset_index(drop=True)
        df2.set_index(x_name, inplace=True)
        df2.interpolate(method="index", axis=0, inplace=True)
        df2.reset_index(inplace=True)
        return df2

    def truncate(self, damage_function_name: str, suffix: str, floodproof_to):
        truncate_to = floodproof_to + 0.01
        dmg = self.functions[damage_function_name]
        new_df_name = damage_function_name + suffix

        damfunc = pd.DataFrame(
            {
                self.hazard_name: self.hazard_values,
                damage_function_name: dmg,
            }
        )

        if floodproof_to not in self.hazard_values:
            damfunc = self.add_row_interp(
                damfunc, self.hazard_name, damage_function_name, floodproof_to
            )

        if truncate_to not in self.hazard_values:
            damfunc = self.add_row_interp(
                damfunc, self.hazard_name, damage_function_name, truncate_to
            )

        damfunc.loc[damfunc[self.hazard_name] < truncate_to, damage_function_name] = 0.0

        # Save the truncated damage function to the damage functions variable
        self.add(
            new_df_name,
            list(damfunc[self.hazard_name]),
            list(damfunc[damage_function_name]),
        )

        # Set the area extract_method to the same as the original damage function
        self.set_area_extraction_method(
            new_df_name, self.extraction_method[damage_function_name]
        )

    def calculate_weighted_damage_function(
        self, damage_function_dict: dict, value_counts_dict: dict
    ):
        new_dfs = dict()

        for damage_type in damage_function_dict.keys():
            percentage_dfs = {
                idx: cnt / value_counts_dict[damage_type].sum()
                for cnt, idx in zip(
                    value_counts_dict[damage_type], value_counts_dict[damage_type].index
                )
            }
            print_percentage_dfs = {
                idx: str(round(cnt / value_counts_dict[damage_type].sum() * 100, 2))
                + "%"
                for cnt, idx in zip(
                    value_counts_dict[damage_type], value_counts_dict[damage_type].index
                )
            }
            self.logger.info(
                f"For the weighted {damage_type} damage function for the area where "
                "population growth will be accomodated, the following damage functions "
                f"are used with a percentual weight of: {print_percentage_dfs}"
            )

            # Calculate the weighted average damage function
            new_damage_function = self.weighted_average_damage_function(
                damage_function_dict[damage_type],
                percentage_dfs,
            )

            # Add the new damage function to the damage functions variable
            new_damage_function_name = "new_composite_area_" + damage_type.lower()
            self.add(new_damage_function_name, self.hazard_values, new_damage_function)
            new_dfs[damage_type] = "new_composite_area_" + damage_type.lower()

            # Set the area extract_method to mean (default)
            self.set_area_extraction_method(new_damage_function_name, "mean")

            self.logger.info(
                f"New damage function '{new_damage_function_name}' created for the new "
                "composite area."
            )

        return new_dfs

    def weighted_average_damage_function(
        self, dfs: List[str], percentage_dfs: dict
    ) -> List[float]:
        weighing = [percentage_dfs[df_id] for df_id in dfs]

        # Compute the weighted average of the damage fractions
        arrays = [np.array(self.functions[df_id]) for df_id in dfs]
        new_damage_fractions = np.average(np.array(arrays), axis=0, weights=weighing)

        return list(new_damage_fractions)

    def get_table(self):
        """Transforms the damage functions into a pandas DataFrame.

        Returns
        -------
        pd.DataFrame
            A DataFrame of vulnerability curves in the format that Delft-FIAT requires.
        """
        vf_values = np.array(list(self.functions.values())).T
        hazard_values = np.array(self.hazard_values).reshape(len(self.hazard_values), 1)
        vf_values = np.concatenate([hazard_values, vf_values], axis=1)

        vf_names_header = np.append(self.hazard_name, list(self.functions.keys()))

        # Add the extract_method under the unit header
        column_names = list()
        column_names.append("#METHOD")
        column_names.extend([self.extraction_method[k] for k in self.functions.keys()])

        vf_names_header = vf_names_header.reshape((1, vf_names_header.shape[0]))

        # Create a dataframe out of the previous array.
        vf_fiat_format = np.concatenate([vf_names_header, vf_values])
        df = pd.DataFrame(vf_fiat_format, columns=column_names)

        return df

    def get_metadata(self) -> List[str]:
        """Retrieves the vulnerability metadata.

        Returns
        -------
        List[str]
            The list with vulnerability metadata
        """
        return [f"#UNIT={self.unit}"]

    def get_new_hazard_values(self, additional_hazard_values):
        all_hazard_values = additional_hazard_values + self.hazard_values
        all_hazard_values = list(set(all_hazard_values))
        all_hazard_values.sort()
        return all_hazard_values

    def interpolate_damage_function(
        self,
        new_hazard_values: list,
        new_fraction_values: list,
        combined_hazard_values: list,
    ):
        hazard_value_column_name = "hazard_values"
        fractions_column_name = "fractions"

        df_output = pd.DataFrame(
            data={hazard_value_column_name: combined_hazard_values}
        )
        df_new = pd.DataFrame(
            {
                hazard_value_column_name: new_hazard_values,
                fractions_column_name: new_fraction_values,
            }
        )
        df_output = df_output.merge(
            df_new,
            how="outer",
            on=hazard_value_column_name,
        )

        # Sort the dataframe
        df_output.sort_values(hazard_value_column_name, inplace=True)

        # Fill the emtpy values in the dataframe.
        # First: interpolate to fill the nan values between values
        df_output.set_index(hazard_value_column_name, inplace=True)
        df_output.interpolate(method="index", limit_area="inside", inplace=True)

        # Second: fill the nan values before the first value per column (with 0)
        df_output.bfill(inplace=True)

        # Third: fill the nan values after the later value per column (with the same value as the last value)
        df_output.ffill(inplace=True)

        # Reset the index to a column
        df_output.reset_index(inplace=True)

        return list(df_output[fractions_column_name])
